#!/usr/bin/env python  
# -*- coding: utf-8 -*-
import ctypes

from app.base import serialize
from app.block.key.keyutil import ssl

from app.config import NID_secp256k1, PRIVATE_KEY_SIZE, PUBLIC_KEY_SIZE, SECRET_SIZE
from app.utils.baseutil import class_params_check  # , str2hex


class PyKey(object):
    def __init__(self, py_key=None):
        if py_key is None:
            self._key = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)
        else:
            assert isinstance(py_key, PyKey), "py_key must be class PyKey"
            self._key = ssl.EC_KEY_dup(py_key._key)
        if self._key is None:
            raise RuntimeError("Pykey __init__ : EC_KEY_new_by_curve_name failed")

    def __del__(self):
        if ssl:
            ssl.EC_KEY_free(self._key)
        self._key = None

    def make_new_key(self, pri_key=None):
        if pri_key:
            return self.set_prikey(pri_key)
        ret = ssl.EC_KEY_generate_key(self._key)
        if not ret:
            raise RuntimeError("EC_KEY_generate_key failed")

    def generate(self, secret=None):
        if secret:
            # if len(secret) > SECRET_SIZE:
            #     secret = secret[-SECRET_SIZE:]
            self.prikey = secret
            priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())
            group = ssl.EC_KEY_get0_group(self._key)
            pub_key = ssl.EC_POINT_new(group)
            ctx = ssl.BN_CTX_new()
            if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):
                raise ValueError("Could not derive public key from the supplied secret.")
            ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)
            ssl.EC_KEY_set_private_key(self._key, priv_key)
            ssl.EC_KEY_set_public_key(self._key, pub_key)
            ssl.EC_POINT_free(pub_key)
            ssl.BN_CTX_free(ctx)
            return self._key
        else:
            return ssl.EC_KEY_generate_key(self._key)

    def set_prikey(self, pri_key):
        assert isinstance(pri_key, str), 'pri parameter must be string'
        pri_size = len(pri_key)
        assert pri_size == PRIVATE_KEY_SIZE, 'asn.1 format pri must be length of ' + PRIVATE_KEY_SIZE
        pri_point = ctypes.create_string_buffer(pri_key)
        # EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);
        # in: pointer to memory with the DER encoded private key
        return ssl.d2i_ECPrivateKey(ctypes.byref(self._key),
                                    ctypes.byref(ctypes.pointer(pri_point)), pri_size)

    def get_prikey(self, hex_value=False):
        if hex_value:
            bn = ssl.EC_KEY_get0_private_key(self._key)
            byte_num = (ssl.BN_num_bits(bn) + 7) / 8
            mb = ctypes.create_string_buffer(byte_num)
            n = ssl.BN_bn2bin(bn, mb)  # int BN_bn2bin(const BIGNUM *a, unsigned char *to);
            pri = mb.raw.rjust(32, chr(0))
            # print 'private', repr(pri), 'len:', len(pri)
            return pri
        else:
            size = ssl.i2d_ECPrivateKey(self._key, 0)
            mb_pri = ctypes.create_string_buffer(size)
            ssl.i2d_ECPrivateKey(self._key, ctypes.byref(ctypes.pointer(mb_pri)))
            # print 'private', repr(mb_pri.raw)
            return mb_pri.raw

    def set_pubkey(self, pub_key):
        assert isinstance(pub_key, str), 'pub_key parameter must be string'
        pub_size = len(pub_key)
        assert pub_size == PUBLIC_KEY_SIZE, 'asn.1 format pub must be length of ' + PUBLIC_KEY_SIZE
        pub_point = ctypes.create_string_buffer(pub_key)
        # return 1 on success and 0 if an error occurred
        return ssl.o2i_ECPublicKey(ctypes.byref(self._key),
                                   ctypes.byref(ctypes.pointer(pub_point)), pub_size)

    def get_pubkey(self):
        #  Encodes a ec public key in an octet string.
        size = ssl.i2o_ECPublicKey(self._key, 0)
        mb = ctypes.create_string_buffer(size)
        ssl.i2o_ECPublicKey(self._key, ctypes.byref(ctypes.pointer(mb)))
        # print 'public', repr(mb.raw)
        return mb.raw

    def sign(self, var_hash, not_hash=False):
        """
        
        :param var_hash: 
        :param not_hash: 
        :return:
        :rtype: str
        """
        if isinstance(var_hash, (int, long)):
            var_hash = serialize.ser_uint256(var_hash)
        assert isinstance(var_hash, (str, bytearray)), "sign param must be bytesarray or str"
        if not not_hash:
            if len(var_hash) != 32:
                raise RuntimeError("hash must be generated by sha256(xxx).digest()")
        sig_size = ssl.ECDSA_size(self._key)
        mb_sig = ctypes.create_string_buffer(sig_size)
        sig_size0 = ctypes.POINTER(ctypes.c_int)()
        ret = ssl.ECDSA_sign(0, var_hash, len(var_hash), mb_sig, ctypes.byref(sig_size0), self._key)
        # ret == 1 mean success
        if ret != 1:
            return None
        return mb_sig.raw

    def verify(self, var_hash, var_sign, not_hash=False):
        if not not_hash:
            if len(var_hash) != 32:
                raise RuntimeError("hash must be generated by sha256(xxx).digest()")
        sig_size = ssl.ECDSA_size(self._key)
        mb_sig = ctypes.create_string_buffer(var_sign, size=sig_size)
        # -1 = error, 0 = bad sig, 1 = good
        return ssl.ECDSA_verify(0, var_hash, len(var_hash), mb_sig, sig_size, self._key) == 1

    @staticmethod
    def static_sign(prikey, uint256_hash_bytes):
        """
        
        :param prikey: 
        :param uint256_hash_bytes: 
        :return:
        :rtype str
        """
        key = PyKey()
        if not key.set_prikey(prikey):
            return False
        return key.sign(uint256_hash_bytes)  # result is sign

    @staticmethod
    def static_verify(pubkey, uint256_hash_bytes, sig_bytes):
        key = PyKey()
        if not key.set_pubkey(pubkey):
            return False
        return key.verify(uint256_hash_bytes, sig_bytes)

    pass


#
# class CKey:
#     def __init__(self):
#         self.POINT_CONVERSION_COMPRESSED = 2
#         self.POINT_CONVERSION_UNCOMPRESSED = 4
#         self.k = ssl.EC_KEY_new_by_curve_name(714)
#
#     def __del__(self):
#         if ssl:
#             ssl.EC_KEY_free(self.k)
#         self.k = None
#
#     def generate(self, secret=None):
#         if secret:
#             self.prikey = secret
#             priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())
#             group = ssl.EC_KEY_get0_group(self.k)
#             pub_key = ssl.EC_POINT_new(group)
#             ctx = ssl.BN_CTX_new()
#             if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):
#                 raise ValueError("Could not derive public key from the supplied secret.")
#             ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)
#             ssl.EC_KEY_set_private_key(self.k, priv_key)
#             ssl.EC_KEY_set_public_key(self.k, pub_key)
#             ssl.EC_POINT_free(pub_key)
#             ssl.BN_CTX_free(ctx)
#             return self.k
#         else:
#             return ssl.EC_KEY_generate_key(self.k)
#
#     def set_privkey(self, key):
#         self.mb = ctypes.create_string_buffer(key)
#         ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))
#
#     def set_pubkey(self, key):
#         self.mb = ctypes.create_string_buffer(key)
#         ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))
#
#     def get_privkey(self):
#         size = ssl.i2d_ECPrivateKey(self.k, 0)
#         mb_pri = ctypes.create_string_buffer(size)
#         ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))
#         return mb_pri.raw
#
#     def get_pubkey(self):
#         size = ssl.i2o_ECPublicKey(self.k, 0)
#         mb = ctypes.create_string_buffer(size)
#         ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))
#         return mb.raw
#
#     def sign(self, hash):
#         sig_size0 = ctypes.c_uint32()
#         sig_size0.value = ssl.ECDSA_size(self.k)
#         mb_sig = ctypes.create_string_buffer(sig_size0.value)
#         result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)
#         assert 1 == result
#         return mb_sig.raw[:sig_size0.value]
#
#     def verify(self, hash, sig):
#         return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1
#
#     def set_compressed(self, compressed):
#         if compressed:
#             form = self.POINT_CONVERSION_COMPRESSED
#         else:
#             form = self.POINT_CONVERSION_UNCOMPRESSED
#         ssl.EC_KEY_set_conv_form(self.k, form)


# def generate_addr():
#     pass


def main():
    p = PyKey()
    # ssl.d2i_ECPrivateKey()
    p.make_new_key()
    print "private key"
    pri_key = p.get_prikey()
    # print str2hex(pri_key)
    pub_key = p.get_pubkey()
    print 'len:', len(pub_key)
    # print str2hex(pub_key)
    print '=========='
    # ret = decoder.decode(pri_key)[0]
    # print ret

    print '****'
    # print pri_key.decode('hex')
    print pri_key.encode('hex')[9:9 + 32]

    # # pri key =
    # s='3f61ead7b4737847ba42de4b4663cb8103f6b382cf0092bd606c3cb29bd31677'
    # # pub key = public '\x04\xe1\xdf\x0c\x84\xd0\xb0\x8f\x95\x87\x00#]\xc3e\xcc\xffc~\x1d\xff\xf7l\xe4\x00\xe7\x9d\xc0\xb6\xd9\xf1\xcd|\xd3\xfda\xd5\r\xddH\xed\xefc$u\t\xfb\xfd\xc7\xc4\xc5\x1f\xe4\x90\xd1\n\xe3\xa6\xa4\x07c\x9d\xa4@\xd8'
    # print 'p2'
    # p2=PyKey()
    # p2.make_new_key(s.decode('hex'))
    # print 'public', repr( p2.get_pubkey())

    pass


if __name__ == '__main__':
    main()
